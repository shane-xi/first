1. 盒模型 内容 + border + padding + margin
xhtml必须被正确嵌套，必须关闭，标签名必须小写

2. 块级元素 div p form ul li 宽度自动填满父级元素宽度
margin和padding　　 行级元素上下设置不会产生边距效果
行级元素 img input a span strong 设置宽高无效

3． 行内元素内一般不可以包含块级元素
display: inline - block 可以设置长宽， 又不是独占一行， 宽度也不是占满父元素
行内元素 zoom: 1 来触发hasLayout， vertical - align

4. 设置定位 z - index大于0， relative 仍会保持占位， absolute会完全脱离文档流， 定位相对于父级的设置了定位的标签元素
float 会改变正常的文档流排列， 会影响到周围元素
float和position: absolute会使display： inline - block

4.5
 href超链接，网络资源
 src   外部资源，将内容内容到文档中当前标签的位置，下载资源，编译执行，暂停其他资源下载和处理

5. 闭合浮动
zoom: 1 触发hasLayout
div clear: both;
br clear all 都有违结构和表现的分离
父元素也浮动 布局受到影响
父元素设置 overflow: hidden 内容增多时候容易造成不会自动换行导致内容被隐藏掉， 无法显示需要溢出的元素: after.clearfix: after {
    content: ".";display: block;height: 0;visibility: hidden;clear: both;
}


6. CSS选择器优先级！ important(作为hack) > style > id > class
head标签里面的style > @
    import > link > link里面的@，link在页面加载时加载，@import是页面加载后
	import > 浏览器默认

7. 浏览器兼容
css里面 reset,重置浏览器默认属性   ie6下的奇葩太多了，浮动双边距，上下margin，微高，png兼容

8. 水平居中
图片文本 对父元素 text - align: center;
定宽的块级元素 margin - left: auto;
margin - right: auto;
不定宽 包含在table中;
display: inline;
父元素relative left: 50 % , 子元素relative left: -50 % ;
9. 竖直居中
父元素高度确定的单行级元素 line - height == hegiht
多行的话 display: table - cell;
vertical - align: middle;
不确定 上下padding相同

10.常用DOM操作：增删改查
 createDocumentFragment()
 nodeType createElement()1;createTextNode()3;
 appendChild();removeChild();replaceChild();insertBefore();
 getElementById()     getElementByClassName()[]数组

11.常用浏览器的内核
使用Webkit内核的浏览器：Safari、Chrome;IE:IE内核

11.
 作用域：变量在声明他们函数体以及这个函数体嵌套的任意函数体内都是有定义的
 作用域链：函数体中不同函数体中定义了同一变量
 this:this总是指向当前函数的所有者对象，this总是在运行时才能确定其具体指向和它的调用对象

12.闭包
 var 局部变量
 JavaScript 中，所有函数都能访问它们上一层的作用域
 call和apply都是改变函数体内的this指向,
 call 参数按顺序传递，apply 参数是放在是数组或这数组对象
 作用是借用其他对象的方法

能够读取其他函数内部的变量
 闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在，
 当在一个函数内定义另外一个函数就会产生闭包

13.function后面没有关键字
匿名函数把脚本包起来，让变量作用域控制在匿名函数内
(function(){})
构建一个GLOBAL{}对象类型作为全局变量，命名空间 
14.
 window.onload=function(){}  window对象会在网页内全部元素加载完毕后除法onload事件；
 JQ中的 $(document).ready();dom节点生成完后执行   不用等图片资源;
 代码压缩  Compressor

15.事件的三个阶段
 捕获，目标，冒泡
 event.stopPropagation();阻止事件冒泡
 event.preventDefault(); 阻止事件默认操作   可以用return false代替
 
16.事件委托
使用事件委托技术能让你避免对特定的每个节点添加事件监听器；相反，事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件   原生js中，用addEventListener监听点击的target

17.事件绑定
.bind()是直接绑定在元素上
.live()则是通过冒泡的方式来绑定到元素上的。更适合列表类型的，绑定到document DOM节点上。和.bind()的优势是支持动态数据（未来）
delegate(selector,[type],[data],fn) 指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数   更加精确
on() 为指定的元素,添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。使用 on() 方法的事件处理程序适用于当前或未来的元素（比如由脚本创建的新元素）


18. 异步传输来更新，不刷新的情况下 部分更新页面
	象服务器发送请求时，我们不必等待结果
ajax的核心是通过XmlHttpRequest获取非本页内容  
	$.ajax({
		type: get是获取，post是更新
		url:
		data:{
					JSON 的四个基本规则：
			1） 并列的数据之间用逗号（", "）分隔。
			2） 映射用冒号（": "）表示。
			3） 并列数据的集合（数组）用方括号("[]")表示。
			4） 映射的集合（对象）用大括号（"{}"）表示。
		}
		datatype:json  解释json数据  eval没有parse安全
		success:function(data){

		}，
		error: function(jqXHR){     
			   alert("发生错误：" + jqXHR.status);  
			}, 
	})

19.而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本  
  callback回调函数来接受数据，在客户端执行
  window.name， iframe，window.postMessage	
  javascript同源策略，一个脚本只能读取来自一个主机名，协议和端口号的窗口和文档属性

20.URL  
 浏览器查找域名的IP(DNS)，给服务器一个HTTP请求
 /重要  造成重定向301；
 服务器处理请求，返回一个html响应    缓存
 HTTP 请求
1. 方法或动作，如 GET 还是 POST；
2.url,地址;
3.请求头    包含客户端的 环境信息，身份验证信息；
有个空行
4.请求正文    提交的表单信息，查询字符串信息等； 
HTTP响应：
1.数字和文字组成的状态码，来表示请求是否成功
2.响应头   服务器的信息，例如服务器的类型，日期，时间，内容类型和长度等
3.响应体   字符串，html代码之类的


！状态码！
1xx:信息类，表示收到了浏览器的请求，在进一步处理中；
2xx：成功， 表示用户请求被正确接受，理解和处理，例如200 OK；
3xx：重定向，表示请求没有成功，客户必须采取进一步的动作；客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL
4xx：客户端错误，表示客户端提交的请求有错误，例如：404 NOT FOUND， 以为请求中所引用的文档不存在.400语法错误，403资源不可用
5xx：服务器错误，表示服务器不能完成对请求的处理 如500



21.懒加载
回答主要是img的src暂存data-src，但是占位得留着。还有textarea容器的特殊性，可以保存所有的代码而不会被强制解释执行.判断其位置是否出现在了可视区域内。如果出现在可视区域了那么就把真实的src地址给赋值上。 并且从数组中删除，避免重复判断。
获取当前img的相对于文档顶的偏移距离减去scrollTop的距离， 然后和浏览器窗口高度在进行比较，如果小于浏览器窗口则出现在了可视区域内了， 反之，则没有

文件合并，压缩，使用CDN托管，缓存的使用


22.数组的方法
  split()切割成数组的形式，join()是将数组转换成字符串;
  push()尾部添加，pop()尾部删除,unshift()头部添加，shift()头部删除

23.HTML5新特性
 	canvas;video,audio;locatStorge浏览器关闭不删除，sessionStorage
 	form    calendar,date,time,emali,url,search



XMLHttpRequest对象
ActiveObjectX
1.var request= new XMLHttpRequest


XHR 发送请求

2.调用open(method,url,async)  默认true   异步
发送send(string)


request.open("post",create.php,true);
request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); 设置http的头i信息
requset.send("name=xiaoming&sex=男");



3.request.onreadystatechange=function(){
     if(request.readyState==4&&requset.status=200) 
     //监听服务器事件是否响应
     //  做一些事情  request.responseText
}



26.
	合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可
语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
重要内容不要用js输出：爬虫不会执行js获取内容
少用iframe：搜索引擎不会抓取iframe中的内容
非装饰性图片必须加alt
提高网站速度：网站速度是搜索引擎排序的一个重要指标


27.
javascript跨域通信

同源：两个文档同源需满足

协议相同
域名相同
端口相同
跨域通信：js进行DOM操作、通信时如果目标与当前窗口不满足同源条件，浏览器为了安全会阻止跨域操作。跨域通信通常有以下方法

如果是log之类的简单单项通信，新建<img>,<script>,<link>,<iframe>元素，通过src，href属性设置为目标url。实现跨域请求
如果请求json数据，使用<script>进行jsonp请求
现代浏览器中多窗口通信使用HTML5规范的targetWindow.postMessage(data, origin);其中data是需要发送的对象，origin是目标窗口的origin。window.addEventListener('message', handler, false);handler的event.data是postMessage发送来的数据，event.origin是发送窗口的origin，event.source是发送消息的窗口引用
内部服务器代理请求跨域url，然后返回数据
跨域请求数据，现代浏览器可使用HTML5规范的CORS功能，只要目标服务器返回HTTP头部Access-Control-Allow-Origin: *即可像普通ajax一样访问跨域资源


27.* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
      绘画 canvas;
      用于媒介回放的 video 和 audio 元素;
      本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
      sessionStorage 的数据在浏览器关闭后自动删除;
      语意化更好的内容元素，比如 article、footer、header、nav、section;
      表单控件，calendar、date、time、email、url、search;
      新的技术webworker, websocket, Geolocation;

      CSS3实现圆角（border-radius），阴影（box-shadow），

对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）

transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜

增加了更多的CSS选择器  多背景 rgba

在CSS3中唯一引入的伪元素是::selection.

媒体查询，多栏布局

border-image


28.sass   增强了css代码的复用性，
  还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。